From 444d3819df532792eacc90e0439f2369449ee5f9 Mon Sep 17 00:00:00 2001
From: Jonathan Lebon <jonathan@jlebon.com>
Date: Thu, 16 Dec 2021 15:59:41 -0500
Subject: [PATCH] Add `ignition-apply` entrypoint

This new entrypoint takes an Ignition config and applies it to the
current rootfs (or one provided by `-root`). This tool could then be
used as part of build processes where we want to bake an Ignition
config, such as in CoreOS layering:

https://github.com/coreos/enhancements/blob/main/os/coreos-layering.md

This in turn should also help drain from the MCO the re-implementation
of large parts of the Ignition spec.

Another approach would be to build on top of `ignition -stage=files`,
but in the end I think we want a cleaner dedicated UX for this workflow
long-term (and in fact we should clean up the hacky places where we call
Ignition like this).

It shouldn't be used by end-users to live apply changes to their
Ignition config. A check that we are in a container is added as a
safeguard against this.

By default, unsupported modifications (like partitioning) trigger
errors, though one may pass `-ignore-unsupported` to override this. Also
by default, remote resources are automatically fetched, though one may
pass `-offline` to override this.
---
 internal/apply/apply.go                       | 120 ++++++++++++++++++
 internal/exec/stages/disks/disks.go           |   9 ++
 internal/exec/stages/fetch/fetch.go           |   4 +
 .../stages/fetch_offline/fetch-offline.go     |   4 +
 internal/exec/stages/files/files.go           |  48 +++++--
 internal/exec/stages/kargs/kargs.go           |   8 ++
 internal/exec/stages/mount/mount.go           |   8 ++
 internal/exec/stages/stages.go                |   1 +
 internal/exec/stages/umount/umount.go         |   8 ++
 internal/main.go                              |  70 ++++++++++
 internal/util/str.go                          |  24 ++++
 11 files changed, 292 insertions(+), 12 deletions(-)
 create mode 100644 internal/apply/apply.go
 create mode 100644 internal/util/str.go

diff --git a/internal/apply/apply.go b/internal/apply/apply.go
new file mode 100644
index 00000000..d4ac38ff
--- /dev/null
+++ b/internal/apply/apply.go
@@ -0,0 +1,120 @@
+// Copyright 2021 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package apply
+
+import (
+	"errors"
+	"fmt"
+	"os"
+	"path/filepath"
+
+	"github.com/coreos/ignition/v2/internal/exec"
+	"github.com/coreos/ignition/v2/internal/exec/stages"
+	_ "github.com/coreos/ignition/v2/internal/exec/stages/disks"
+	_ "github.com/coreos/ignition/v2/internal/exec/stages/fetch"
+	_ "github.com/coreos/ignition/v2/internal/exec/stages/fetch_offline"
+	_ "github.com/coreos/ignition/v2/internal/exec/stages/files"
+	_ "github.com/coreos/ignition/v2/internal/exec/stages/kargs"
+	_ "github.com/coreos/ignition/v2/internal/exec/stages/mount"
+	_ "github.com/coreos/ignition/v2/internal/exec/stages/umount"
+	"github.com/coreos/ignition/v2/internal/log"
+	"github.com/coreos/ignition/v2/internal/resource"
+	"github.com/coreos/ignition/v2/internal/state"
+	"github.com/coreos/ignition/v2/internal/util"
+
+	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+)
+
+type Flags struct {
+	Root              string
+	IgnoreUnsupported bool
+	Offline           bool
+}
+
+func inContainer() bool {
+	// this is set by various container tools like systemd-nspawn, podman,
+	// docker, etc...
+	if val, _ := os.LookupEnv("container"); val != "" {
+		return true
+	}
+
+	// check for the podman or docker container files
+	paths := []string{"/run/.containerenv", "/.dockerenv"}
+	for _, path := range paths {
+		if _, err := os.Stat(path); err == nil {
+			return true
+		}
+	}
+
+	return false
+}
+
+func Run(cfg types.Config, flags Flags, logger *log.Logger) error {
+	if !inContainer() {
+		return errors.New("this tool is not designed to run on a host system; reprovision the machine instead")
+	}
+
+	// make absolute because our code assumes that
+	var err error
+	if flags.Root, err = filepath.Abs(flags.Root); err != nil {
+		return err
+	}
+
+	fetcher := resource.Fetcher{
+		Logger:  logger,
+		Offline: flags.Offline,
+	}
+
+	state := state.State{}
+	cfgFetcher := exec.ConfigFetcher{
+		Logger:  logger,
+		Fetcher: &fetcher,
+		State:   &state,
+	}
+
+	finalCfg, err := cfgFetcher.RenderConfig(cfg)
+	if err != nil {
+		return err
+	}
+
+	// verify upfront if we'll need networking but we're not allowed
+	if flags.Offline {
+		stage := stages.Get("fetch-offline").Create(logger, flags.Root, fetcher, &state)
+		if err := stage.Run(finalCfg); err != nil {
+			return err
+		}
+	}
+
+	// Order in which to apply live. This is overkill since effectively only
+	// `files` supports it right now, but let's be extensible. Also ensures that
+	// all stages are accounted for.
+	stagesOrder := []string{"fetch-offline", "fetch", "kargs", "disks", "mount", "files", "umount"}
+	allStages := stages.Names()
+	if len(stagesOrder) != len(allStages) {
+		panic(fmt.Sprintf("%v != %v", stagesOrder, allStages))
+	}
+
+	for _, stageName := range stagesOrder {
+		if !util.StrSliceContains(allStages, stageName) {
+			panic(fmt.Sprintf("stage '%s' invalid", stageName))
+		}
+		stage := stages.Get(stageName).Create(logger, flags.Root, fetcher, &state)
+		if err := stage.Apply(finalCfg, flags.IgnoreUnsupported); err != nil {
+			return fmt.Errorf("running stage '%s': %w", stageName, err)
+		}
+	}
+
+	return nil
+}
diff --git a/internal/exec/stages/disks/disks.go b/internal/exec/stages/disks/disks.go
index 920490cc..745fa19c 100644
--- a/internal/exec/stages/disks/disks.go
+++ b/internal/exec/stages/disks/disks.go
@@ -19,6 +19,7 @@
 package disks
 
 import (
+	"errors"
 	"fmt"
 	"os/exec"
 
@@ -72,6 +73,14 @@ func isNoOp(config types.Config) bool {
 		len(config.Storage.Luks) == 0
 }
 
+func (s stage) Apply(config types.Config, ignoreUnsupported bool) error {
+	// in theory, we could support this, but for now we don't need it
+	if isNoOp(config) || ignoreUnsupported {
+		return nil
+	}
+	return errors.New("cannot apply disk modifications live")
+}
+
 func (s stage) Run(config types.Config) error {
 	// Interacting with disks/partitions/raids/filesystems in general can cause
 	// udev races. If we do not need to  do anything, we also do not need to
diff --git a/internal/exec/stages/fetch/fetch.go b/internal/exec/stages/fetch/fetch.go
index 3c65ecb8..f163509e 100644
--- a/internal/exec/stages/fetch/fetch.go
+++ b/internal/exec/stages/fetch/fetch.go
@@ -59,6 +59,10 @@ func (stage) Name() string {
 	return name
 }
 
+func (s stage) Apply(_ types.Config, _ bool) error {
+	return nil
+}
+
 func (s stage) Run(_ types.Config) error {
 	// Nothing - all we do is fetch and allow anything else in the initramfs to run
 	s.Logger.Info("fetch complete")
diff --git a/internal/exec/stages/fetch_offline/fetch-offline.go b/internal/exec/stages/fetch_offline/fetch-offline.go
index 92e3c180..dcea43a8 100644
--- a/internal/exec/stages/fetch_offline/fetch-offline.go
+++ b/internal/exec/stages/fetch_offline/fetch-offline.go
@@ -64,6 +64,10 @@ func (stage) Name() string {
 	return name
 }
 
+func (s stage) Apply(_ types.Config, _ bool) error {
+	return nil
+}
+
 func (s stage) Run(cfg types.Config) error {
 	if needsNet, err := configNeedsNet(&cfg); err != nil {
 		return err
diff --git a/internal/exec/stages/files/files.go b/internal/exec/stages/files/files.go
index e0851440..6e574531 100644
--- a/internal/exec/stages/files/files.go
+++ b/internal/exec/stages/files/files.go
@@ -66,13 +66,32 @@ func (stage) Name() string {
 	return name
 }
 
+func (s stage) Apply(config types.Config, ignoreUnsupported bool) error {
+	return s.runImpl(config, true, ignoreUnsupported)
+}
+
 func (s stage) Run(config types.Config) error {
-	if err := s.checkRelabeling(); err != nil {
-		return fmt.Errorf("failed to check if SELinux labeling required: %v", err)
+	return s.runImpl(config, false, false)
+}
+
+func (s stage) runImpl(config types.Config, isApply bool, applyIgnoreUnsupported bool) error {
+	if !isApply {
+		// !isApply: SELinux is handled differently in container flows
+		if err := s.checkRelabeling(); err != nil {
+			return fmt.Errorf("failed to check if SELinux labeling required: %v", err)
+		}
 	}
 
-	if err := s.createPasswd(config); err != nil {
-		return fmt.Errorf("failed to create users/groups: %v", err)
+	// theoretically could support this, but the main user (CoreOS layering)
+	// does not: https://github.com/coreos/rpm-ostree/issues/3435
+	if isApply {
+		if !applyIgnoreUnsupported && (len(config.Passwd.Users) > 0 || len(config.Passwd.Groups) > 0) {
+			return errors.New("cannot apply passwd live")
+		}
+	} else {
+		if err := s.createPasswd(config); err != nil {
+			return fmt.Errorf("failed to create users/groups: %v", err)
+		}
 	}
 
 	if err := s.createFilesystemsEntries(config); err != nil {
@@ -83,16 +102,21 @@ func (s stage) Run(config types.Config) error {
 		return fmt.Errorf("failed to create units: %v", err)
 	}
 
-	if err := s.createCrypttabEntries(config); err != nil {
-		return fmt.Errorf("creating crypttab entries: %v", err)
-	}
+	if !isApply {
+		// !isApply: we don't support LUKS, so this isn't necessary
+		if err := s.createCrypttabEntries(config); err != nil {
+			return fmt.Errorf("creating crypttab entries: %v", err)
+		}
 
-	if err := s.createResultFile(); err != nil {
-		return fmt.Errorf("creating result file: %v", err)
-	}
+		// !isApply: we support running Ignition multiple times
+		if err := s.createResultFile(); err != nil {
+			return fmt.Errorf("creating result file: %v", err)
+		}
 
-	if err := s.relabelFiles(); err != nil {
-		return fmt.Errorf("failed to handle relabeling: %v", err)
+		// !isApply: SELinux is handled differently in container flows
+		if err := s.relabelFiles(); err != nil {
+			return fmt.Errorf("failed to handle relabeling: %v", err)
+		}
 	}
 
 	return nil
diff --git a/internal/exec/stages/kargs/kargs.go b/internal/exec/stages/kargs/kargs.go
index f3ae05c5..7267709f 100644
--- a/internal/exec/stages/kargs/kargs.go
+++ b/internal/exec/stages/kargs/kargs.go
@@ -15,6 +15,7 @@
 package kargs
 
 import (
+	"errors"
 	"fmt"
 	"os/exec"
 
@@ -65,6 +66,13 @@ func isNoOp(config types.Config) bool {
 		len(config.KernelArguments.ShouldNotExist) == 0
 }
 
+func (s stage) Apply(config types.Config, ignoreUnsupported bool) error {
+	if isNoOp(config) || ignoreUnsupported {
+		return nil
+	}
+	return errors.New("cannot apply kargs modifications live")
+}
+
 func (s stage) Run(config types.Config) error {
 	if isNoOp(config) {
 		return nil
diff --git a/internal/exec/stages/mount/mount.go b/internal/exec/stages/mount/mount.go
index e57ef663..1c25dfed 100644
--- a/internal/exec/stages/mount/mount.go
+++ b/internal/exec/stages/mount/mount.go
@@ -19,6 +19,7 @@
 package mount
 
 import (
+	"errors"
 	"fmt"
 	"os"
 	"os/exec"
@@ -68,6 +69,13 @@ func (stage) Name() string {
 	return name
 }
 
+func (s stage) Apply(config types.Config, ignoreUnsupported bool) error {
+	if len(config.Storage.Filesystems) == 0 || ignoreUnsupported {
+		return nil
+	}
+	return errors.New("cannot apply filesystems modifications live")
+}
+
 func (s stage) Run(config types.Config) error {
 	fss := []types.Filesystem{}
 	for _, fs := range config.Storage.Filesystems {
diff --git a/internal/exec/stages/stages.go b/internal/exec/stages/stages.go
index 7b1b6ea8..dc4d7d3e 100644
--- a/internal/exec/stages/stages.go
+++ b/internal/exec/stages/stages.go
@@ -25,6 +25,7 @@ import (
 // Stage is responsible for actually executing a stage of the configuration.
 type Stage interface {
 	Run(config types.Config) error
+	Apply(config types.Config, ignoreUnsupported bool) error
 	Name() string
 }
 
diff --git a/internal/exec/stages/umount/umount.go b/internal/exec/stages/umount/umount.go
index e0b1d3ef..d7b7fbba 100644
--- a/internal/exec/stages/umount/umount.go
+++ b/internal/exec/stages/umount/umount.go
@@ -19,6 +19,7 @@
 package umount
 
 import (
+	"errors"
 	"sort"
 
 	cutil "github.com/coreos/ignition/v2/config/util"
@@ -64,6 +65,13 @@ func (stage) Name() string {
 	return name
 }
 
+func (s stage) Apply(config types.Config, ignoreUnsupported bool) error {
+	if len(config.Storage.Filesystems) == 0 || ignoreUnsupported {
+		return nil
+	}
+	return errors.New("cannot apply filesystems modifications live")
+}
+
 func (s stage) Run(config types.Config) error {
 	fss := []types.Filesystem{}
 	for _, fs := range config.Storage.Filesystems {
diff --git a/internal/main.go b/internal/main.go
index aa021c2e..10d66a1f 100644
--- a/internal/main.go
+++ b/internal/main.go
@@ -17,9 +17,13 @@ package main
 import (
 	"flag"
 	"fmt"
+	"io/ioutil"
 	"os"
+	"path/filepath"
 	"time"
 
+	"github.com/coreos/ignition/v2/config"
+	"github.com/coreos/ignition/v2/internal/apply"
 	"github.com/coreos/ignition/v2/internal/exec"
 	"github.com/coreos/ignition/v2/internal/exec/stages"
 	_ "github.com/coreos/ignition/v2/internal/exec/stages/disks"
@@ -33,9 +37,19 @@ import (
 	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/state"
 	"github.com/coreos/ignition/v2/internal/version"
+	"github.com/spf13/pflag"
 )
 
 func main() {
+	if filepath.Base(os.Args[0]) == "ignition-apply" {
+		ignitionApplyMain()
+	} else {
+		// otherwise, assume regular Ignition
+		ignitionMain()
+	}
+}
+
+func ignitionMain() {
 	flags := struct {
 		configCache  string
 		fetchTimeout time.Duration
@@ -117,3 +131,59 @@ func main() {
 	}
 	logger.Info("Ignition finished successfully")
 }
+
+func ignitionApplyMain() {
+	printVersion := false
+	flags := apply.Flags{}
+	pflag.BoolVar(&printVersion, "version", false, "print the version of ignition-apply")
+	pflag.StringVar(&flags.Root, "root", "/", "root of the filesystem")
+	pflag.BoolVar(&flags.IgnoreUnsupported, "ignore-unsupported", false, "ignore unsupported config sections")
+	pflag.BoolVar(&flags.Offline, "offline", false, "error out if config references remote resources")
+	pflag.Usage = func() {
+		fmt.Fprintf(pflag.CommandLine.Output(), "Usage: %s [options] config.ign\n", os.Args[0])
+		fmt.Fprintf(pflag.CommandLine.Output(), "Options:\n")
+		pflag.PrintDefaults()
+	}
+	pflag.Parse()
+
+	if printVersion {
+		fmt.Printf("%s\n", version.String)
+		return
+	}
+
+	if pflag.NArg() != 1 {
+		pflag.Usage()
+		os.Exit(1)
+	}
+	cfgArg := pflag.Arg(0)
+
+	logger := log.New(true)
+	defer logger.Close()
+
+	logger.Info(version.String)
+
+	var blob []byte
+	var err error
+	if cfgArg == "-" {
+		blob, err = ioutil.ReadAll(os.Stdin)
+	} else {
+		// XXX: could in the future support fetching directly from HTTP(S) + `-checksum|-insecure` ?
+		blob, err = ioutil.ReadFile(cfgArg)
+	}
+	if err != nil {
+		logger.Crit("couldn't read config: %v", err)
+		os.Exit(1)
+	}
+
+	cfg, rpt, err := config.Parse(blob)
+	logger.LogReport(rpt)
+	if rpt.IsFatal() || err != nil {
+		logger.Crit("couldn't parse config: %v", err)
+		os.Exit(1)
+	}
+
+	if err := apply.Run(cfg, flags, &logger); err != nil {
+		logger.Crit("failed to apply: %v", err)
+		os.Exit(1)
+	}
+}
diff --git a/internal/util/str.go b/internal/util/str.go
new file mode 100644
index 00000000..dceae5ef
--- /dev/null
+++ b/internal/util/str.go
@@ -0,0 +1,24 @@
+// Copyright 2022 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package util
+
+func StrSliceContains(slice []string, s string) bool {
+	for _, e := range slice {
+		if e == s {
+			return true
+		}
+	}
+	return false
+}
-- 
2.35.1

