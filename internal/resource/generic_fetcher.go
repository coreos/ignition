// Copyright 2016 CoreOS, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resource

import (
	"encoding/hex"
	"fmt"
	"io"
	"io/ioutil"
	"net/url"
	"os"
	"path/filepath"
	"sync"

	"github.com/coreos/ignition/v2/config/shared/errors"
	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
	"github.com/coreos/ignition/v2/internal/util"
)

type FetchResult struct {
	Src string
	Uri *url.URL
	Cfg []byte
}

type FetchOp struct {
	Src          string
	File         *types.File
	ResCfg       *types.Resource
	Append       bool
	FetchOptions FetchOptions
}

type AppendMutex struct {
	mtx  sync.Mutex
	flag bool
}

func (f *AppendMutex) TestAndSet() (ret bool) {
	f.mtx.Lock()
	ret, f.flag = !f.flag, true
	f.mtx.Unlock()
	return
}

func makeResourceFetchOptions(r types.Resource) []FetchOp {
	fetches := []FetchOp{}
	sources := r.GetSources()
	for _, src := range sources {
		op := FetchOp{Src: string(src), ResCfg: &r}
		fetches = append(fetches, op)
	}
	return fetches
}

func makeFileFetchOptions(f types.File) ([]FetchOp, []FetchOp) {
	fetches := []FetchOp{}
	sources := f.Contents.GetSources()
	for _, src := range sources {
		op := FetchOp{Src: string(src), ResCfg: &f.Contents, File: &f}
		fetches = append(fetches, op)
	}

	appendies := []FetchOp{}
	for _, appendee := range f.Append {
		sources := appendee.GetSources()
		for _, src := range sources {
			op := FetchOp{Src: string(src), File: &f, ResCfg: &appendee, Append: true}
			appendies = append(appendies, op)
		}
	}
	return fetches, appendies
}

// PerformFetch performs a fetch operation generated by PrepareFetch, retrieving
// the file and writing it to disk. Any encountered errors are returned.
func (f *Fetcher) PerformFetch(op FetchOp, msg string, abort <-chan int, mtx *AppendMutex) (ret FetchResult, err error) {
	const (
		DefaultDirectoryPermissions os.FileMode = 0755
		DefaultFilePermissions      os.FileMode = 0644
	)

	const (
		ParsingUrl = iota
		Hashing
		ParsingHTTPHeaders
		CreatingTempFile
		ChangingPermissions
		Fetching
		Appending
		finish
	)

	ret.Src = op.Src
	l := f.Logger
	var tmp *os.File
	l.Info("%s: started", msg)

	for stage := ParsingUrl; stage != finish; stage++ {
		select {
		case <-abort:
			l.Warning("%s: operation cancelled", msg)
			err = errors.ErrFetchCancelled
			return
		default:
			switch stage {
			case ParsingUrl:
				ret.Uri, err = url.Parse(op.Src)
				if err != nil {
					l.Debug("%s: error parsing url - %v", msg, err)
					return
				}

			case Hashing:
				if op.ResCfg == nil {
					continue
				}
				op.FetchOptions.Hash, err = util.GetHasher(op.ResCfg.Verification)
				if err != nil {
					l.Debug("%s: error verifying file - %v", msg, err)
					return
				}
				if op.FetchOptions.Hash != nil {
					// explicitly ignoring the error here because the config should already
					// be validated by this point
					_, expectedSumString, _ := util.HashParts(op.ResCfg.Verification)
					op.FetchOptions.ExpectedSum, err = hex.DecodeString(expectedSumString)
					if err != nil {
						l.Debug("%s: error parsing verification string - %q: %v", msg, expectedSumString, err)
						return
					}
				}

			case ParsingHTTPHeaders:
				if op.ResCfg != nil && op.ResCfg.HTTPHeaders != nil && len(op.ResCfg.HTTPHeaders) > 0 {
					op.FetchOptions.Headers, err = op.ResCfg.HTTPHeaders.Parse()
					if err != nil {
						l.Debug("%s: error parsing http headers - %v: %v", msg, op.ResCfg.HTTPHeaders, err)
						return
					}
				}

			case CreatingTempFile:
				if op.File == nil {
					continue
				}
				err = os.MkdirAll(filepath.Dir(op.File.Node.Path), DefaultDirectoryPermissions)
				if err != nil {
					l.Debug("%s: error making dir for file - %v", msg, err)
					return
				}
				// Create a temporary file in the same directory to ensure it's on the same filesystem
				tmp, err = ioutil.TempFile(filepath.Dir(op.File.Node.Path), "tmp")
				if err != nil {
					l.Debug("%s: error creating tmp file - %v", msg, err)
					return
				}
				defer tmp.Close()

			case ChangingPermissions:
				if op.File == nil {
					continue
				}
				// ioutil.TempFile defaults to 0600
				err = tmp.Chmod(DefaultFilePermissions)
				if err != nil {
					l.Debug("%s: error changing file permissions - %q: %v", msg, tmp.Name(), err)
					return
				}
				// sometimes the following line will fail (the file might be renamed),
				// but that's ok (we wanted to keep the file in that case).
				defer os.Remove(tmp.Name())

			case Fetching:
				if op.ResCfg != nil && op.ResCfg.Compression != nil {
					op.FetchOptions.Compression = *op.ResCfg.Compression
				}
				if op.File == nil {
					ret.Cfg, err = f.FetchToBuffer(*ret.Uri, op.FetchOptions, abort)
				} else {
					err = f.Fetch(*ret.Uri, tmp, op.FetchOptions, abort)
				}
				if err != nil {
					l.Debug("%s: failed - %s", msg, err)
					return
				}

			case Appending:
				if op.File == nil {
					break
				}

				if mtx != nil && !mtx.TestAndSet() {
					err = fmt.Errorf("used by another fetcher")
					l.Debug("%s: error appending to the file - %s", msg, err)
					return
				}

				if op.Append {
					var finfo os.FileInfo
					// Make sure that we're appending to a file
					finfo, err = os.Lstat(op.File.Node.Path)
					switch {
					case os.IsNotExist(err):
						// No problem, we'll create it.
						break
					case err != nil:
						return
					default:
						if !finfo.Mode().IsRegular() {
							err = fmt.Errorf("can only append to files: %q", op.File.Node.Path)
							return
						}
					}

					// Open with the default permissions, we'll chown/chmod it later
					var targetFile *os.File
					targetFile, err = os.OpenFile(op.File.Node.Path, os.O_WRONLY|os.O_APPEND|os.O_CREATE, DefaultFilePermissions)
					if err != nil {
						return
					}
					defer targetFile.Close()

					if _, err = tmp.Seek(0, io.SeekStart); err != nil {
						return
					}
					if _, err = io.Copy(targetFile, tmp); err != nil {
						return
					}
				} else {
					if err = os.Rename(tmp.Name(), op.File.Node.Path); err != nil {
						return
					}
				}
			}
		}
	}
	l.Info("%s: successfully finished", msg)
	return
}

func (f *Fetcher) FetchData(args ...interface{}) (FetchResult, error) {
	var fetches []FetchOp
	var appendies []FetchOp

	for _, arg := range args {
		switch t := arg.(type) {
		case types.Resource:
			fetches = makeResourceFetchOptions(t)
		case types.File:
			fetches, appendies = makeFileFetchOptions(t)
		default:
			return FetchResult{}, fmt.Errorf("bad arguments for fetching: %+v", t)
		}
	}

	fetcher := func(ops []FetchOp, msg string) (FetchResult, error) {
		abort := make(chan int)
		sem := AppendMutex{}

		results := make(chan struct {
			FetchResult
			error
		}, len(ops))

		for idx, op := range ops {
			var logprefix string
			if op.File != nil {
				logprefix = fmt.Sprintf("[%d] %s %s -> %s", idx, msg, op.Src, op.File.Node.Path)
			} else {
				logprefix = fmt.Sprintf("[%d] %s %s", idx, msg, op.Src)
			}

			go func(op FetchOp) {
				ret, err := f.PerformFetch(op, logprefix, abort, &sem)
				results <- struct {
					FetchResult
					error
				}{ret, err}
			}(op)
		}

		closed := false
		var data FetchResult
		var err error
		for range ops {
			d := <-results
			if closed {
				continue
			}
			data = d.FetchResult
			err = d.error
			if err == nil {
				closed = true
				close(abort)
			}
		}
		return data, err
	}

	// Fetching
	data, err := fetcher(fetches, "Fetching")
	if err != nil || len(appendies) == 0 {
		return data, err
	}
	// Appending
	return fetcher(appendies, "Appending")
}
