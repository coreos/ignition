From 867219f95571720d6ea9ccd306f1ceb0a2fb918c Mon Sep 17 00:00:00 2001
From: Jonathan Lebon <jonathan@jlebon.com>
Date: Fri, 3 Dec 2021 17:16:47 -0500
Subject: [PATCH 5/8] internal/exec: factor out config fetching

This is mostly a code move, though we do invent a new `ConfigFetcher`
type which the engine now has to instantiate to call `RenderConfig`.
This is prep for being able to render configs the same way from
elsewhere.
---
 internal/exec/config_fetcher.go | 146 ++++++++++++++++++++++++++++++++
 internal/exec/engine.go         | 118 ++------------------------
 2 files changed, 151 insertions(+), 113 deletions(-)
 create mode 100644 internal/exec/config_fetcher.go

diff --git a/internal/exec/config_fetcher.go b/internal/exec/config_fetcher.go
new file mode 100644
index 00000000..a99212f0
--- /dev/null
+++ b/internal/exec/config_fetcher.go
@@ -0,0 +1,146 @@
+// Copyright 2021 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package exec
+
+import (
+	"crypto/sha512"
+	"encoding/hex"
+	"net/http"
+	"net/url"
+
+	"github.com/coreos/ignition/v2/config"
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/internal/log"
+	"github.com/coreos/ignition/v2/internal/resource"
+	"github.com/coreos/ignition/v2/internal/state"
+	"github.com/coreos/ignition/v2/internal/util"
+
+	latest "github.com/coreos/ignition/v2/config/v3_4_experimental"
+	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+)
+
+type ConfigFetcher struct {
+	Logger  *log.Logger
+	Fetcher *resource.Fetcher
+	State   *state.State
+}
+
+// RenderConfig evaluates "ignition.config.replace" and "ignition.config.append"
+// in the given config and returns the result. If "ignition.config.replace" is
+// set, the referenced and evaluted config will be returned. Otherwise, if
+// "ignition.config.append" is set, each of the referenced configs will be
+// evaluated and appended to the provided config. If neither option is set, the
+// provided config will be returned unmodified. An updated fetcher will be
+// returned with any new timeouts set.
+func (f *ConfigFetcher) RenderConfig(cfg types.Config) (types.Config, error) {
+	if cfgRef := cfg.Ignition.Config.Replace; cfgRef.Source != nil {
+		newCfg, err := f.fetchReferencedConfig(cfgRef)
+		if err != nil {
+			return types.Config{}, err
+		}
+
+		// Replace the HTTP client in the fetcher to be configured with the
+		// timeouts of the new config
+		err = f.Fetcher.UpdateHttpTimeoutsAndCAs(newCfg.Ignition.Timeouts, newCfg.Ignition.Security.TLS.CertificateAuthorities, newCfg.Ignition.Proxy)
+		if err != nil {
+			return types.Config{}, err
+		}
+
+		return f.RenderConfig(newCfg)
+	}
+
+	appendedCfg := cfg
+	for _, cfgRef := range cfg.Ignition.Config.Merge {
+		newCfg, err := f.fetchReferencedConfig(cfgRef)
+		if err != nil {
+			return types.Config{}, err
+		}
+
+		// Merge the old config with the new config before the new config has
+		// been rendered, so we can use the new config's timeouts and CAs when
+		// fetching more configs.
+		cfgForFetcherSettings := latest.Merge(appendedCfg, newCfg)
+		err = f.Fetcher.UpdateHttpTimeoutsAndCAs(cfgForFetcherSettings.Ignition.Timeouts, cfgForFetcherSettings.Ignition.Security.TLS.CertificateAuthorities, cfgForFetcherSettings.Ignition.Proxy)
+		if err != nil {
+			return types.Config{}, err
+		}
+
+		newCfg, err = f.RenderConfig(newCfg)
+		if err != nil {
+			return types.Config{}, err
+		}
+
+		appendedCfg = latest.Merge(appendedCfg, newCfg)
+	}
+	return appendedCfg, nil
+}
+
+// fetchReferencedConfig fetches and parses the requested config.
+// cfgRef.Source must not be nil
+func (f *ConfigFetcher) fetchReferencedConfig(cfgRef types.Resource) (types.Config, error) {
+	// this is also already checked at validation time
+	if cfgRef.Source == nil {
+		f.Logger.Crit("invalid referenced config: %v", errors.ErrSourceRequired)
+		return types.Config{}, errors.ErrSourceRequired
+	}
+	u, err := url.Parse(*cfgRef.Source)
+	if err != nil {
+		return types.Config{}, err
+	}
+	var headers http.Header
+	if cfgRef.HTTPHeaders != nil && len(cfgRef.HTTPHeaders) > 0 {
+		headers, err = cfgRef.HTTPHeaders.Parse()
+		if err != nil {
+			return types.Config{}, err
+		}
+	}
+	compression := ""
+	if cfgRef.Compression != nil {
+		compression = *cfgRef.Compression
+	}
+	rawCfg, err := f.Fetcher.FetchToBuffer(*u, resource.FetchOptions{
+		Headers:     headers,
+		Compression: compression,
+	})
+	if err != nil {
+		return types.Config{}, err
+	}
+
+	hash := sha512.Sum512(rawCfg)
+	if u.Scheme != "data" {
+		f.Logger.Debug("fetched referenced config at %s with SHA512: %s", *cfgRef.Source, hex.EncodeToString(hash[:]))
+	} else {
+		// data url's might contain secrets
+		f.Logger.Debug("fetched referenced config from data url with SHA512: %s", hex.EncodeToString(hash[:]))
+	}
+
+	f.State.FetchedConfigs = append(f.State.FetchedConfigs, state.FetchedConfig{
+		Kind:       "user",
+		Source:     u.Path,
+		Referenced: true,
+	})
+
+	if err := util.AssertValid(cfgRef.Verification, rawCfg); err != nil {
+		return types.Config{}, err
+	}
+
+	cfg, r, err := config.Parse(rawCfg)
+	f.Logger.LogReport(r)
+	if err != nil {
+		return types.Config{}, err
+	}
+
+	return cfg, nil
+}
diff --git a/internal/exec/engine.go b/internal/exec/engine.go
index a02a30aa..f651b1c9 100644
--- a/internal/exec/engine.go
+++ b/internal/exec/engine.go
@@ -15,20 +15,15 @@
 package exec
 
 import (
-	"crypto/sha512"
-	"encoding/hex"
 	"encoding/json"
 	"fmt"
 	"io/ioutil"
-	"net/http"
-	"net/url"
 	"os"
 	"strconv"
 	"strings"
 	"time"
 
 	"github.com/coreos/go-systemd/v22/journal"
-	"github.com/coreos/ignition/v2/config"
 	"github.com/coreos/ignition/v2/config/shared/errors"
 	latest "github.com/coreos/ignition/v2/config/v3_4_experimental"
 	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
@@ -41,7 +36,6 @@ import (
 	"github.com/coreos/ignition/v2/internal/providers/system"
 	"github.com/coreos/ignition/v2/internal/resource"
 	"github.com/coreos/ignition/v2/internal/state"
-	"github.com/coreos/ignition/v2/internal/util"
 
 	"github.com/coreos/vcontext/report"
 	"github.com/coreos/vcontext/validate"
@@ -332,115 +326,13 @@ func (e *Engine) fetchProviderConfig() (types.Config, error) {
 		return types.Config{}, err
 	}
 
-	return e.renderConfig(cfg)
-}
-
-// renderConfig evaluates "ignition.config.replace" and "ignition.config.append"
-// in the given config and returns the result. If "ignition.config.replace" is
-// set, the referenced and evaluted config will be returned. Otherwise, if
-// "ignition.config.append" is set, each of the referenced configs will be
-// evaluated and appended to the provided config. If neither option is set, the
-// provided config will be returned unmodified. An updated fetcher will be
-// returned with any new timeouts set.
-func (e *Engine) renderConfig(cfg types.Config) (types.Config, error) {
-	if cfgRef := cfg.Ignition.Config.Replace; cfgRef.Source != nil {
-		newCfg, err := e.fetchReferencedConfig(cfgRef)
-		if err != nil {
-			return types.Config{}, err
-		}
-
-		// Replace the HTTP client in the fetcher to be configured with the
-		// timeouts of the new config
-		err = e.Fetcher.UpdateHttpTimeoutsAndCAs(newCfg.Ignition.Timeouts, newCfg.Ignition.Security.TLS.CertificateAuthorities, newCfg.Ignition.Proxy)
-		if err != nil {
-			return types.Config{}, err
-		}
-
-		return e.renderConfig(newCfg)
-	}
-
-	appendedCfg := cfg
-	for _, cfgRef := range cfg.Ignition.Config.Merge {
-		newCfg, err := e.fetchReferencedConfig(cfgRef)
-		if err != nil {
-			return types.Config{}, err
-		}
-
-		// Merge the old config with the new config before the new config has
-		// been rendered, so we can use the new config's timeouts and CAs when
-		// fetching more configs.
-		cfgForFetcherSettings := latest.Merge(appendedCfg, newCfg)
-		err = e.Fetcher.UpdateHttpTimeoutsAndCAs(cfgForFetcherSettings.Ignition.Timeouts, cfgForFetcherSettings.Ignition.Security.TLS.CertificateAuthorities, cfgForFetcherSettings.Ignition.Proxy)
-		if err != nil {
-			return types.Config{}, err
-		}
-
-		newCfg, err = e.renderConfig(newCfg)
-		if err != nil {
-			return types.Config{}, err
-		}
-
-		appendedCfg = latest.Merge(appendedCfg, newCfg)
-	}
-	return appendedCfg, nil
-}
-
-// fetchReferencedConfig fetches and parses the requested config.
-// cfgRef.Source must not be nil
-func (e *Engine) fetchReferencedConfig(cfgRef types.Resource) (types.Config, error) {
-	// this is also already checked at validation time
-	if cfgRef.Source == nil {
-		e.Logger.Crit("invalid referenced config: %v", errors.ErrSourceRequired)
-		return types.Config{}, errors.ErrSourceRequired
-	}
-	u, err := url.Parse(*cfgRef.Source)
-	if err != nil {
-		return types.Config{}, err
-	}
-	var headers http.Header
-	if cfgRef.HTTPHeaders != nil && len(cfgRef.HTTPHeaders) > 0 {
-		headers, err = cfgRef.HTTPHeaders.Parse()
-		if err != nil {
-			return types.Config{}, err
-		}
-	}
-	compression := ""
-	if cfgRef.Compression != nil {
-		compression = *cfgRef.Compression
-	}
-	rawCfg, err := e.Fetcher.FetchToBuffer(*u, resource.FetchOptions{
-		Headers:     headers,
-		Compression: compression,
-	})
-	if err != nil {
-		return types.Config{}, err
-	}
-
-	hash := sha512.Sum512(rawCfg)
-	if u.Scheme != "data" {
-		e.Logger.Debug("fetched referenced config at %s with SHA512: %s", *cfgRef.Source, hex.EncodeToString(hash[:]))
-	} else {
-		// data url's might contain secrets
-		e.Logger.Debug("fetched referenced config from data url with SHA512: %s", hex.EncodeToString(hash[:]))
-	}
-
-	e.State.FetchedConfigs = append(e.State.FetchedConfigs, state.FetchedConfig{
-		Kind:       "user",
-		Source:     u.Path,
-		Referenced: true,
-	})
-
-	if err := util.AssertValid(cfgRef.Verification, rawCfg); err != nil {
-		return types.Config{}, err
-	}
-
-	cfg, r, err := config.Parse(rawCfg)
-	e.Logger.LogReport(r)
-	if err != nil {
-		return types.Config{}, err
+	configFetcher := ConfigFetcher{
+		Logger:  e.Logger,
+		Fetcher: e.Fetcher,
+		State:   e.State,
 	}
 
-	return cfg, nil
+	return configFetcher.RenderConfig(cfg)
 }
 
 func (e *Engine) signalNeedNet() error {
-- 
2.35.1

